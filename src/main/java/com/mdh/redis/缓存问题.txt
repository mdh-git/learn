
1.缓存击穿
    查询数据在数据库中不存在

    解决方案：
        1. 缓存空数据，设置一个过期时间，避免频繁访问数据库（消耗内存，可能会发生数据不一致）
        2. 布隆过滤器，（先查询布隆过滤器，后查询redis缓存）
            将所有可能存在的数据哈希到一个大的bitmap中，查询时先判断bitmap中是否存在，不存在则查询数据库，存在则返回缓存数据 （Redisson，Guava （设置误判率））
            存在误判的可能 : 增加布隆过滤器的数组大小，降低误判率（增大内存消耗）

2.缓存穿透
    查询数据在数据库中存在，但缓存中没有（可能过期导致的）(热点key突然失效)

    解决方案：
        1.互斥锁（数据强一致性，性能差）
            查询未命中缓存的数据，加锁从数据库中获取，直到查到数据，重建缓存，写入缓存，释放锁 （只有一个线程可以访问数据库，别的线程需要等待）
        2.逻辑过期（高可用，性能优，不能保证数据绝对一致性）
            key:1  value:{"id":123,"name":"zhangsan","expireTime":1596816000000}}

            线程1： 查询缓存数据，发现逻辑过期，获取互斥锁，开启新的线程，返回过期数据
            线程2：                                    新的线程：查询数据库，重建缓存，写入缓存（更改逻辑过期时间），释放锁
            线程3：                       查询缓存，数据逻辑过期，获取锁失败，返回过期数据
            线程4：                                                                                                获取缓存数据，并且数据没有逻辑过期

3.缓存雪崩
    大量缓存数据在同一时间失效、redis服务器宕机

    解决方案：
        1.给不同的key的TTL添加随机值
        2.Redis集群提高服务的可用性（哨兵模式、集群模式）
        3.给缓存业务添加限流降级策略（nginx或者gateway）
        4.添加多级缓存（Guava或Caffeine）（先读取多级缓存，没有数据在读取redis）


4.数据一致性问题
    缓存与数据库数据不一致

    解决方案：
        1.延时双删（业务不复杂，对实时要求不高，有脏数据风险，不能保证数据绝对一致性）
            删除缓存数据，修改数据库，延时一会，删除数据库

        2.互斥锁
            1.添加分布式锁（Redisson）（性能比较低）
            2.读多写少的场景下可以使用Redis中的读写锁 （强一致性，性能低）
                共享锁： 读锁readLock，加锁之后，其他线程可以共享度操作
                排他锁：独占锁writeLock，加锁之后，其他线程不能读写操作，直到释放锁
            3.使用消息中间件MQ
                业务上修改数据时，写数据到数据库，并发送消息给MQ，监听到消息后，更新缓存
            4.使用Canal同步数据（基于mysql的主从同步来实现的，监听MySQL binlog日志）
