# Java 中15种锁的介绍
~~~
可重入锁、乐观锁、悲观锁、公平锁、非公平锁、自旋锁、偏向锁、分段锁等
https://blog.csdn.net/qq_22167989/article/details/87829034
https://www.jianshu.com/p/ac60ef75ddaa
~~~

## synchronized
~~~
锁的状态：
1.无锁状态
2.偏向锁状态
3.轻量级锁状态
4.重量级锁状态

锁的状态是通过对象监视器在对象头中的字段来表明的。
四种状态会随着竞争的情况逐渐升级，而且是不可逆的过程，即不可降级。
这四种状态都不是Java语言中的锁，而是Jvm为了提高锁的获取与释放效率而做的优化(使用synchronized时)。

(1):偏向锁
偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。

(2):轻量级
轻量级锁是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。

(3):重量级锁
重量级锁是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。
~~~

## 自旋锁
~~~
自旋锁（spinlock）：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。

它是为实现保护共享资源而提出一种锁机制。其实，自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。
无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，也就说，在任何时刻最多只能有一个执行单元获得锁。
但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。
但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，”自旋”一词就是因此而得名。
~~~

## 自旋锁与互斥锁
~~~
1.自旋锁与互斥锁都是为了实现保护资源共享的机制。
2.无论是自旋锁还是互斥锁，在任意时刻，都最多只能有一个保持者。
3.获取互斥锁的线程，如果锁已经被占用，则该线程将进入睡眠状态；获取自旋锁的线程则不会睡眠，而是一直循环等待锁释放。
~~~


## 自旋锁总结
~~~
1.自旋锁：线程获取锁的时候，如果锁被其他线程持有，则当前线程将循环等待，直到获取到锁。
2.自旋锁等待期间，线程的状态不会改变，线程一直是用户态并且是活动的(active)。
3.自旋锁如果持有锁的时间太长，则会导致其它等待获取锁的线程耗尽CPU。
4.自旋锁本身无法保证公平性，同时也无法保证可重入性。
5.基于自旋锁，可以实现具备公平性和可重入性质的锁。
~~~

## 可重入锁
~~~
可重入锁又名递归锁

是指在同一个在外层方法获取锁的时候,再进入该线程的内层方法会自动获取锁(前提,锁对象必须是同一个对象),
不会因为之前已经获取过还没释放而阻塞。

java中ReentrantLock和HashMap是非synchronized都是可重入锁,可重入锁的一个优点是可一定程度避免死锁。
~~~