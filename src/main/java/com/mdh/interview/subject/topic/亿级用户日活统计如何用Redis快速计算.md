# 亿级用户日活统计如何用Redis快速计算
~~~
https://zhuanlan.zhihu.com/p/262003901

方案一：使用string（排除）
    每个用户每天登陆需要占据1对KV的话，那一亿就是(48*100000000)/1024/1024/1024=4.47G。

方案二：bitmap
    在redis 2.2.0版本之后，新增了一个位图数据，其实它不是一种数据结构。
    实际上它就是一个一个字符串结构，只不过value是一个二进制数据，每一位只能是0或者1。
    redis单独对bitmap提供了一套命令。可以对任意一位进行设置和读取。
    命令：
    语法：SETBIT key offset value
    语法：GETBIT key offset
    bitmap可以很好的满足一些需要记录大量而简单信息的场景。所占空间十分小。

方案三：HyperLogLog
    HyperLogLog是一种概率性数据结构，在标准误差0.81%的前提下，能够统计2^64个数据。
    所以 HyperLogLog 适合在比如统计日活月活此类的对精度要不不高的场景。
    HyperLogLog使用概率算法来统计集合的近似基数。而它算法的最本源则是伯努利过程。
~~~

## BITMAP
~~~
因为bitmap的每一位只占据1bit的空间 ，所以利用这个特性我们可以把每一天作为key，value为1亿用户的活跃度状态。
假设一个用户一天内只要登录了一次就算活跃。活跃我们就记为1，不活跃我们就记为0。
把用户Id作为偏移量(offset)。这样我们一个key就可以存储1亿用户的活跃状态。

用户登录时，使用setbit命令和用户id（假设id=123456）标记当日（2020-10-05）用户已经登录，具体命令如下：
# 时间复杂度O(1) setbit login:20201005 123456 1

每日用户登录数量统计
# 时间复杂度O(N) bitcount login:20201005
~~~

## HyperLogLog 
~~~
redis从2.8.9之后增加了HyperLogLog数据结构。
这个数据结构，根据redis的官网介绍，这是一个概率数据结构，用来估算数据的基数。
能通过牺牲准确率来减少内存空间的消耗。

PFADD 添加一个元素，如果重复，只算作一个
PFCOUNT 返回元素数量的近似值
PFMERGE 将多个 HyperLogLog 合并为一个 HyperLogLog
~~~

## 总结
~~~
bitmap的优势是：非常均衡的特性，精准统计，可以得到每个统计对象的状态，秒出。
缺点是：当你的统计对象数量十分十分巨大时，可能会占用到一点存储空间，但也可在接受范围内。
也可以通过分片，或者压缩的额外手段去解决。

HyperLogLog的优势是：可以统计夸张到无法想象的数量，并且占用小的夸张的内存。 
缺点是：建立在牺牲准确率的基础上，而且无法得到每个统计对象的状态。
~~~