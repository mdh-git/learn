# 死锁

## 死锁产生的四个条件
~~~
在多线程环境中有两个或者两个以上的线程去争夺同一个共享资源，造成相互等待的结果，如果没有外部干预，线程会一直阻塞，无法执行

互斥条件： 共享资源X和Y只能被一个线程占用
请求保持条件：线程T1已经取得共享资源X，在等待共享资源Y的时候，不释放共享资源X
        解决：一次性申请全部的资源
不可抢占条件：其他线程不能强行抢占线程T1占有的资源
        解决：占用资源的线程在去申请其他资源时，申请不到，可以主动释放自己占有的资源
循环等待条件：循环等待条件，线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源就是循环等待
        解决：按照顺序申请资源

出现死锁，可以通过jstack命令去导出线程的dump日志，从dump日志中定位到具体死锁的代码
修改代码去破坏四个中的任意一个（互斥条件是锁本身的特性），就可以解决死锁（重启服务，kill线程）


~~~

## 排查死锁问题
~~~
可以使用jdk自带的命令行工具排查：
1. 使用jps查找运行的Java进程： jps -l
2.使用jstack查看线程堆栈信息： jstack -l 进程id
可以利用图形化工具，比如 JConsole。出现线程死锁后，点击JConsole线程面板的检查死锁按钮，将会看到线程的死锁信息。

~~~