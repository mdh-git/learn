# 线程池

## java实现多线程的四种方法
~~~
继承Thread类

实现Runnable接口,没有返回值,不抛异常 必须重写run()方法

实现Callable接口,有返回值,会有异常 必须重写call()方法

线程池
~~~

## 优势
~~~
线程池做的工作主要是控制运行的线程的数量,处理过程中将任务放入队列,然后在线程创建后启动这些任务,如果线程数量超过了最大
数量,超出数量的线程排队等候,等其它线程执行完毕,再从队列中取出任务来执行。

主要特点: 线程复用,控制最大并发数,管理线程

第一: 降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
第二: 提高响应速度。当任务到达时,任务可以不需要等到线程创建就能立即执行。
第三: 提高线程的可管理性。线程是稀缺资源,如果无限制的创建,不仅会消耗系统资源,还会降低系统的稳定性,使用线程池可以进
     行统一的分配,调优和监控


~~~

## java提供的线程池有五种
~~~

时间调度:
Executors.newScheduledThreadPool(int corePoolSize, ThreadFactory threadFactory);

java8 里面:
Executors.newWorkStealingPool(int parallelism);
java8新增,使用目前机器上可用的处理器作为它的并行级别

重点三个:
(1) Executors.newFixedThreadPool(int nThreads);  执行长期的任务,性能好
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads,   (int corePoolSize)
                                      nThreads,   (int maximumPoolSize)
                                      0L,
                                      TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }
1. 创建一个定长线程池,可控制线程最大并发数量,超出的线程会在队列中等待。
2. newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的,使用LinkedBlockingQueue<Runnable>()


(2) Executors.newSingleThreadExecutor(); 一个任务一个任务执行的场景
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }
1. 创建一个单线程的线程池,它只会用唯一的工作线程来完成任务,保证所有任务按照指定顺序执行。
2. newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置成1,它使用的LinkedBlockingQueue<Runnable>()

(3) Executors.newCachedThreadPool(); 执行很多短期异步的小程序或者负载较轻的服务
public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }
1. 创建一个可缓存线程池,如果线程池长度超过处理需要,可灵活回收空闲线程,若无可回收,则新建线程。
2. newCachedThreadPool将corePoolSize设置为0,将maximumPoolSize设置为Integer.MAX_VALUE,使用SynchronousQueue<Runnable>()
    也就是说来了任务就会创建线程运行,当线程空闲超过60秒,就销毁线程
~~~

## IDEA的阿里巴巴规约插件提示：
~~~
阿里规范不建议使用Executors去创建线程池
https://blog.csdn.net/superit401/article/details/103355600


“ 线程池不允许使用Executors去创建，而是通过ThreadPoolExecutor的方式，
这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。”

即：不能使用
ExecutorService excutorService = Executors.newCachedThreadPool();

改为ThreadPoolExecutor：
ThreadPoolExecutor pool1 = new ThreadPoolExecutor(5,200,60,
                TimeUnit.SECONDS,new ArrayBlockingQueue<Runnable> (5),Executors.defaultThreadFactory());

或 

ThreadFactory namedThreadFactory = new ThreadFactoryBuilder()
        .setNameFormat("demo-pool-%d").build();
ExecutorService pool = new ThreadPoolExecutor(5, 200,
        0L, TimeUnit.MILLISECONDS,
        new LinkedBlockingQueue<Runnable>(1024), namedThreadFactory, new ThreadPoolExecutor.AbortPolicy());


注意需要引入guava包，否则ThreadFactoryBuilder会报错
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>28.1-jre</version>
</dependency>
~~~