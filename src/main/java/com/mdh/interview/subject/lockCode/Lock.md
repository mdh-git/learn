# Lock

## 公平锁和非公平锁
~~~
Java语言中有许多原生线程安全的数据结构，比如ArrayBlockingQueue、CopyOnWriteArrayList、LinkedBlockingQueue，
它们线程安全的实现方式并非通过synchronized(非公平)关键字，而是通过java.util.concurrent.locks.ReentrantLock来实现。 

“可重入锁实现原理”。
ReentrantLock的实现是基于其内部类FairSync(公平锁)和NonFairSync(非公平锁)实现的。 其可重入性是基于Thread.currentThread()实现的: 如果当前线程已经获得了执行序列中的锁，
那执行序列之后的所有方法都可以获得这个锁。

公平锁：(多个线程按照申请锁的顺序来获取锁)

公平和非公平锁的队列都基于锁内部维护的一个双向链表，表结点Node的值就是每一个请求当前锁的线程。公平锁则在于每次都是依次从队首取值。
锁的实现方式是基于如下几点：
表结点Node和状态state的volatile关键字。
sum.misc.Unsafe.compareAndSet的原子操作(见附录)。

非公平锁：(多个线程获取锁的顺序并不一定是按照申请锁的顺序)(优势在于吞吐量比公平锁高)
在等待锁的过程中， 如果有任意新的线程妄图获取锁，都是有很大的几率直接获取到锁的。
~~~

## 可重入锁(又名递归锁)
~~~
可重入锁，指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。
synchronized 和   ReentrantLock 都是可重入锁。
可重入锁的意义之一在于防止死锁。

实现原理实现是通过为每个锁关联一个请求计数器和一个占有它的线程。当计数为0时，认为锁是未被占有的；线程请求一个未被占有的锁时，
JVM将记录锁的占有者，并且将请求计数器置为1 。
如果同一个线程再次请求这个锁，计数器将递增；
每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。
~~~

## 自旋锁
~~~
指尝试获取锁的线程不会立即阻塞,而是采用循环的方式去尝试获取锁,这样的好处是减少线程上下文切换的消耗,缺点是循环会消耗CPU资源
~~~

## 独占锁(写锁)/共享锁(读锁)/互斥锁
~~~
独占锁: 指该锁一次只能被一个线程所持有, 
    ReentrantLock和synchronized都是独占锁

共享锁: 指该锁可以被多个线程持有
    ReentrantReadWriteLock其读锁是共享锁,写锁是独占锁

读锁的共享锁可保证并发读是非常高效的,读写,写读,写写的过程是互斥的。
~~~